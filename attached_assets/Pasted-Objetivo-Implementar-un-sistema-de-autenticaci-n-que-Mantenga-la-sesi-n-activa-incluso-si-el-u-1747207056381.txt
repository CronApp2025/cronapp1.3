Objetivo:
Implementar un sistema de autenticaci√≥n que:

Mantenga la sesi√≥n activa incluso si el usuario cierra la pesta√±a/navegador (persistencia controlada).

No almacene tokens ni datos sensibles en la base de datos o el cliente (evitar localStorage/cookies vulnerables).

Invalide la sesi√≥n inmediatamente al cerrar sesi√≥n, incluso si el token a√∫n no ha expirado.

Instrucciones T√©cnicas (Sin C√≥digo):
1. Estrategia de Tokens Seguros:
Usa JWT (JSON Web Tokens) con los siguientes par√°metros:

Firma HMAC-SHA256: Clave secreta compleja (nunca hardcodeada, usa variables de entorno).

Expiraci√≥n corta: 15-30 minutos (exp claim).

Datos m√≠nimos: Solo user_id y un UUID √∫nico por sesi√≥n (no incluir emails, roles, etc.).

No guardar tokens en la base de datos: Solo almacenar el UUID de sesi√≥n en el cliente (cookie HttpOnly + Secure + SameSite=Strict).

2. Invalidaci√≥n Activa al Cerrar Sesi√≥n:
Paso 1 (Logout):

Enviar el UUID de la sesi√≥n al backend.

Agregar el UUID a una lista denegada (denylist) en memoria o cach√© (Redis/Memcached) con TTL = tiempo de expiraci√≥n del token.

Paso 2 (Validaci√≥n en cada request):

Antes de autorizar cualquier petici√≥n, verificar si el UUID del token est√° en la denylist.

Si est√°, devolver 401 Unauthorized y forzar logout en el frontend.

3. Persistencia Controlada de la Sesi√≥n:
Frontend:

Usar sessionStorage (no localStorage) para almacenar el UUID, pero solo si el usuario marca "Mantener sesi√≥n iniciada".

Si se cierra la pesta√±a/navegador, sessionStorage se borrar√°, pero la sesi√≥n seguir√° activa en el backend hasta que expire el token.

Backend:

Si el token expira (por tiempo), auto-redirigir al login.

4. Blindaje Contra Robo de Tokens:
Encabezados de Seguridad:

Strict-Transport-Security: Forzar HTTPS.

Content-Security-Policy: Bloquear scripts externos.

Protecci√≥n Extra:

Vincular el token a la IP del usuario (opcional, pero aumenta seguridad).

Flujo de Cierre de Sesi√≥n a Prueba de Fallos:
Usuario hace logout:

Frontend borra sessionStorage y cookies.

Backend invalida el UUID en la denylist.

Token a√∫n no expirado:

Cualquier petici√≥n con ese UUID ser√° rechazada (401), aunque el token sea t√©cnicamente v√°lido.

Token expirado:

La denylist lo elimina autom√°ticamente (TTL).

Pruebas Obligatorias:
Test 1:

Cerrar sesi√≥n ‚Üí Intentar usar el mismo token para acceder al dashboard ‚Üí Debe fallar.

Test 2:

Cerrar el navegador ‚Üí Abrir y pegar la URL del dashboard ‚Üí Solo carga si el token est√° activo y no est√° en la denylist.

Test 3:

Robo simulado de token ‚Üí Si el atacante intenta usarlo, la denylist lo bloquea tras el logout.

Estructura de Respuesta:
[TOKEN] Generando JWT seguro...  
  - Sin datos sensibles ‚úÖ  
  - Expiraci√≥n: 15 minutos ‚úÖ  

[LOGOUT] Invalidando sesi√≥n...  
  - UUID a√±adido a denylist (TTL=15m) ‚úÖ  
  - Test post-logout: Token rechazado. ‚úÖ  

[PERSISTENCIA] Sesi√≥n tras cerrar pesta√±a...  
  - Token sigue activo (no est√° en denylist) ‚Üí Dashboard accesible.  
  - Token en denylist ‚Üí Redirige a login. ‚úÖ  

[SEGURIDAD] Headers configurados...  
  - HSTS ‚úÖ | CSP ‚úÖ | XSS Protection ‚úÖ  
¬°No parar hasta que ning√∫n token inv√°lido o robado permita acceso al dashboard! üîê